#!/usr/bin/env python


import sys,string
import astropy.io.fits as pyfits
import argparse
import datetime
import numpy as np
import astropy.table as t

from scipy.stats import iqr
from scipy.ndimage import binary_closing

from desispec import io
from desiutil.log import get_logger

from desispec.preproc import parse_sec_keyword, get_readout_mode, get_amp_ids
from desispec.maskbits import ccdmask
from desispec.workflow.tableio import load_table, load_tables


#Parser to take arguments from command line
parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter,
description="Compute a mask using dark images",
 epilog='''Input is a list of raw dark images (Possibly with different exposure times). Raw images are fully preprocessed then for sets of N darks the min absolute value is computed as a first guess of the mask. From M such guesses an or operation is performed, finally binary_closing fills in gaps and columns with more than a certain fraction of masking will be filtered''')

parser.add_argument('-i','--image', type = str, default = None, required = False, nargs="*",
                    help = 'paths to raw dark image fits files (either this or --firstnight/--lastnight needs to be set)')
#could be changed to use particular night range, but not yet done

parser.add_argument('-f','--firstnight', type = str, default = None, required = False,
                    help = 'first night to use for automatic discovery')
parser.add_argument('-l','--lastnight', type = str, default = None, required = False,
                    help = 'last night to use for automatic discovery')

parser.add_argument('--use-existing-preproc', action='store_true',
                    help = 'use existing preproc files instead of recomputing them')
parser.add_argument('--preproc-basedir', type = str, default = None, required = False, 
                    help = 'look for preproc-files in here instead of the usual directory structure')

parser.add_argument('-o','--outfile', type = str, default = None, required = True,
                    help = 'output mask filename')
parser.add_argument('--camera',type = str, required = True,
                    help = 'header HDU (int or string)')

parser.add_argument('--colfrac', type = float, default=0.4, required=False,
                    help='If more than this fraction of pixels are blocked in a column, the whole column in that amplifier is blocked.')
parser.add_argument('--closeiter', type = int, default=10, required=False,
                    help='Number of iterations for the binary closing operation')

parser.add_argument('--mask', type = str, default = None, required = False,
                    help = 'Path to a previous mask file. If given, the output is the bitwise OR of the input mask and the mask created by this script.')

parser.add_argument('--frames-per-coadd', type = int, default = 4, required = False,
                    help = 'number of dark frames to compute the min(abs(preprocessed dark)) from')
parser.add_argument('--coadds-per-mask', type = int, default = 5, required = False,
                    help = 'number of masks to combine via or')

parser.add_argument('--threshold', type = float, default = 70./1200, required = False,
                    help = 'threshold for mask (in counts per s, default 70 counts / 1200s exposure )')

#maybe those 2 options would be useful as well
parser.add_argument('--savestat', action='store_true', required = False,
                    help = 'Whether to save the intermediate dark frame statistics')
parser.add_argument('--outfilestat', type = str, default = None, required = False,
                    help = 'output image filename for statistics file')

args = parser.parse_args()
log  = get_logger()

#search for files
if (args.firstnight is not None) & (args.lastnight is not None) & (args.image is None):
    dt_firstnight=datetime.datetime.strptime(f"{args.firstnight}","%Y%m%d")
    dt_lastnight=datetime.datetime.strptime(f"{args.lastnight}","%Y%m%d")
    datearr=np.arange(dt_firstnight,dt_lastnight+datetime.timedelta(days=1),datetime.timedelta(days=1),dtype='datetime64[D]')
    datearr=np.datetime_as_string(datearr)
    datearr=np.char.replace(datearr,'-','')
    exptab_names=[io.findfile('exptable', d) for d in datearr]
    exptab=t.vstack(load_tables(exptab_names))
    select=exptab['OBSTYPE']=='dark'
    select&=exptab['PROGRAM']=='morning darks'
    exptab=exptab[select]
    nights=exptab['NIGHT']
    expids=exptab['EXPID']
    if not args.use_existing_preproc:
        filenames=[io.findfile('raw', night=n, expid=e) for n,e in zip(nights,expids)]
    else:
        filenames=[io.findfile('preproc', night=n, expid=e, camera=args.camera, specprod=args.preproc_basedir+'/') for n,e in zip(nights,expids)]
elif  args.image is not None:
    if (args.firstnight is not None) | (args.lastnight is not None):
        log.critical("Need to supplied both --firstnight/--lastnight and --image, using explicit files given by --image")

    filenames=args.image
    filenames.sort()
else:
    log.critical("Need to supply either --firstnight and --lastnight or a list of images in --image")
    raise ValueError("Need to supply either --firstnight and --lastnight or a list of images in --image")



log.info("read images ...")

shape=None

#Read all the dark images
readout_mode=None
cam_header=None
images=[]
nights=[]
expids=[]
filenames_used=[]
for filename in filenames :

    log.info(f"Reading file {filename}")

    # collect header data
    with pyfits.open(filename) as fitsfile:
        primary_header = fitsfile[0].header
        if not "EXPTIME" in primary_header :
            primary_header = fitsfile[1].header

        exptime = primary_header["EXPTIME"]
        if exptime<1000:
                log.critical(f"Morning darks should be exptime=1200s, but found {exptime}s")
                raise TypeError(f"Morning darks should be exptime=1200s, but found {exptime}s")

        if not args.use_existing_preproc:
            extname=f'{(args.camera)}'.upper()
        else:
            extname='IMAGE'
        #this is a check on 2amp/4amp detector modes
        if readout_mode is None:
            cam_header=fitsfile[extname].header
            readout_mode = get_readout_mode(cam_header)
        else:
            readout_mode2=get_readout_mode(fitsfile[extname].header)
            if readout_mode2 != readout_mode:
                log.critical("A set of spectra with different readout modes was submitted")
                raise TypeError("A set of spectra with different readout modes was submitted")
        
        #maybe add additional checks if e.g. the config and camera used are actually the same

    # read raw data and preprocess them
    #@JG: maybe change those params as needed, e.g. to the default preproc settings
    if not args.use_existing_preproc:
        img = io.read_raw(filename, args.camera,
                        bias=True,
                        nogain=False,
                        nocosmic=True,
                        mask=False,
                        dark=True,
                        pixflat=False,
                        nocrosstalk=True,
                        ccd_calibration_filename=False)
        img=img.pix
    else:
        with pyfits.open(filename) as fitsfile:
            img=fitsfile['IMAGE'].data

    shape=img.shape
    log.info(f"adding dark {filename} divided by exposure time {exptime} s")
    expids.append(primary_header['EXPID'])
    nights.append(primary_header['NIGHT'])
    filenames_used.append(filename)
    images.append(img/exptime)


nights=np.array(nights)
images=np.array(images)
expids=np.array(expids)
filenames_used=np.array(filenames_used)

#truncate number of images to simplify things for later
if images.shape[0]%(args.frames_per_coadd*args.coadds_per_mask) !=0:
    log.warning("number of images not divisable by args.frames_per_coadd*args.coadds_per_mask, discarding the last few")
    nimages=images.shape[0]//(args.frames_per_coadd*args.coadds_per_mask)
    nimages*=(args.frames_per_coadd*args.coadds_per_mask)
    nights=nights[:nimages]
    expids=expids[:nimages]
    filenames_used=filenames_used[:nimages]
    images=images[:nimages,...]

expids.shape=[-1, args.coadds_per_mask,args.frames_per_coadd]
nights.shape=[-1, args.coadds_per_mask,args.frames_per_coadd]
filenames_used.shape=[-1, args.coadds_per_mask,args.frames_per_coadd]
images.shape=[-1, args.coadds_per_mask,args.frames_per_coadd,images.shape[1],images.shape[2]]


log.info("compute min(abs(preprocessed dark)) image ...")
min_image = np.min(np.abs(images), axis=2)



if args.savestat:
    for night,expid,fnames,mimage in zip(nights,expids,filenames_used,min_image):
        
        log.info(f"writing stats output to {args.outfilestat.replace('.fits',f'{night[0][0]}.fits')} ...")
        #need to think about which further stats to output, not doing anything here yet

        hdulist=pyfits.HDUList([pyfits.PrimaryHDU()]+[pyfits.ImageHDU(mimage, name=f"MINABS_{n[0]}_{e[0]}") for n,e in zip(night,expid)])
        for n,e,hdu in zip(night,expid,hdulist[1:]):
            hdu.header["NIGHT"]=" ".join(n.astype(str))
            hdu.header["EXPID"]=" ".join(e.astype(str))

        #Write header info
        for i, filename in enumerate(fnames.flatten()) :
            hdulist[0].header[f"INPUT{i:03d}"]=filename
        hdulist[0].header["CAMERA"]=args.camera
        hdulist[0].header["NFRAMES"]=(args.coadds_per_mask,'number of frames used for minimum absolute')

        hdulist.writeto(args.outfilestat.replace('.fits',f'_{night[0][0]}.fits'), overwrite=True)
        log.info("Done writing statistics file")


log.info("combine masks via or operation ...")

mask   = np.zeros(min_image.shape, dtype=np.int32)
above_threshold=min_image>args.threshold
mask[mask] = ccdmask.BAD
combined_mask=(mask[:,0,...])

for i in range(1,mask.shape[1]):
    combined_mask|=mask[:,i,...]
mask=combined_mask    

log.info("close gaps via binary closing ...")

closed_mask=mask
for i,m in enumerate(closed_mask):
    #Close incompletely blocked regions
    closed_mask[i,...] = binary_closing(m, iterations=args.closeiter, structure=np.ones([2,2]).astype(np.int32)) #returns binary array

log.info("add first/last valid mask to first/last few rows")
for i,m in enumerate(closed_mask):
    any_masked=np.any(closed_mask,axis=1).nonzero()
    closed_mask[:any_masked[0][0],:]=closed_mask[[any_masked[0][0]],:]
    closed_mask[any_masked[0][-1]:,:]=closed_mask[[any_masked[0][-1]],:]

closed_mask[closed_mask] = ccdmask.BAD
mask|=closed_mask



#the loop starting here goes over individual mesks, everything before should work on all masks to be processed
log.info("check which columns have a large fraction masked")
for i,m in enumerate(mask):
    print(readout_mode)
    amp_ids=get_amp_ids(cam_header)

    if readout_mode=="4Amp" or readout_mode=="2AmpUpDown":
        #Block entire columns above a certain threshold per amplifier
        bad_pix = (m>0)
        bad_pix_upper = bad_pix[0:bad_pix.shape[0]//2,:]
        bad_pix_lower = bad_pix[bad_pix.shape[0]//2:bad_pix.shape[0],:]
        bad_frac_upper = np.sum(bad_pix_upper, axis=0)/(bad_pix.shape[0]//2)
        bad_frac_lower = np.sum(bad_pix_lower, axis=0)/(bad_pix.shape[0]//2)
        bad_cols_upper = np.where(bad_frac_upper>=args.colfrac)
        bad_cols_lower = np.where(bad_frac_lower>=args.colfrac)
        m[0:bad_pix.shape[0]//2,bad_cols_upper] |= ccdmask.BAD
        m[bad_pix.shape[0]//2:bad_pix.shape[0],bad_cols_lower] |= ccdmask.BAD
    elif readout_mode=="2AmpLeftRight":
        #Block entire columns above a certain threshold per amplifier
        bad_pix = (mask>0)
        bad_pix_all = bad_pix[0:bad_pix.shape[0],:]
        bad_frac_all = np.sum(bad_pix_all, axis=0)/bad_pix.shape[0]   
        bad_cols_all = np.where(bad_frac_all>=args.colfrac)
        m[0:bad_pix.shape[0],bad_cols_all] |= ccdmask.BAD
    else:
        msg = f'Unknown {readout_mode=}'
        log.critical(msg)
        raise ValueError(msg)
    mask[i,...]=m

log.info("encorporate previous mask")
for i,m in enumerate(mask):
    #Incorporate a previously created mask using a bitwise OR
    if args.mask!=None:
        mask_old = pyfits.open(args.mask)[0].data
        mask = (mask | mask_old)
        log.info("Taken bitwise OR of input mask and the generated mask")

    mask_percent = np.sum(mask>0)*100/np.product(mask.shape)

log.info("write outputs")
for i,(m,n,e,fnames) in enumerate(zip(mask,nights,expids,filenames_used)):
    
    log.info(f"writing {args.outfile.replace('.fits',f'_{n[0][0]}.fits')}")

    #Write fits file with header info

    hdu = pyfits.PrimaryHDU(mask.astype("int16"))
    hdu.header["NFRAMES"] = (args.frames_per_coadd, 'number of frames used for minimum absolute')
    hdu.header["NMASKS"] = (args.coadds_per_mask, 'number of masks combined with or')
    hdu.header["COLFRAC"] = (args.colfrac, 'Bad pixel fraction for blocked column in amp')
    hdu.header["CAMERA"] = (args.camera, 'header HDU (int or string)')
    hdu.header["CLOSEITER"] = (args.closeiter, 'binary cloing iterations')
    hdu.header["MASKFRAC"] = (mask_percent, 'Percent of pixels masked')
    hdu.header["OLDMASK"] = (args.mask, 'Path to input mask')
    hdu.header["NIGHTSS"] = (" ".join(np.unique(n.astype(str)).flatten()), 'NIGHTS included')
    hdu.header["EXPIDS"] = (" ".join(e.astype(str).flatten()), 'EXPIDs included')

    for i, filename in enumerate(fnames.flatten()) :
        hdu.header[f"INPUT{i:03d}"] = filename
    hdu.header["EXTNAME"] = "MASK"
    hdu.header["BUNIT"] = ""
    
    #add the night of first frame used to the filename
    hdu.writeto(args.outfile.replace('.fits',f'_{n[0][0]}.fits'), overwrite=True)
    log.info("Saved masks file")
